pragma ever-solidity >= 0.64.0;

import '@itgold/everscale-tip/contracts/TIP4_3/TIP4_3Collection.sol';
import '@itgold/everscale-tip/contracts/TIP4_2/TIP4_2Collection.sol';

import "./structures/ITile.tsol";
import "./interfaces/ISegmintCollection.tsol";

import "./libraries/MsgFlag.tsol";
import "./libraries/ErrorCodes.tsol";
import './SegmintNft.tsol';

contract SegmintCollection is TIP4_2Collection, TIP4_3Collection, ITile, ISegmintCollection {

    address private static owner_;

    uint16 private static nonce_;
    bool private mintDisabled_;

    // x = 0..100, y = 0.100 (100 pieces by 10 pixes - 1000x1000)
    // uint7 - 128 - x coord << 7
    // uint7 - 128 - y coord
    mapping (uint14 => TileColors) private tiles_;

    // Small mapping index -> nftId;
    mapping (uint14 => uint64) private tileOwner_;

    uint32 private nftCounter_;                   // Just nft counter
    uint32 private currentEpoch_;                 // Num of current epoch
    uint14 private currentEpochTilesLeft_;        // How many tiles left to mint before new epoch is started
    uint128 private currentEpochPixelTilePrice_;  // Price per tile
    uint128 private epochTilePriceGrow_;

    uint128 constant remainOnNft_ = 0.3 ever;

    event MintDisabledChanged(bool newValue);
    event TileColorify(uint32 nftId, uint32 nftEpoch, uint10 pixelStartX, uint10 pixelStartY, TileColors tileColors);
    event NftMinted(uint32 nftId, uint32 nftEpoch, address owner, uint10 pixelStartX, uint10 pixelStartY, uint10 pixelEndX, uint10 pixelEndY);
    event EpochChanged(uint32 newEpoch, uint128 oneTileClaimPrice);

    constructor(
        TvmCell codeNft,
        TvmCell codeIndex,
        TvmCell codeIndexBasis,
        string jsonMetadata
    ) TIP4_1Collection (
        codeNft
    ) TIP4_2Collection (
        jsonMetadata
    ) TIP4_3Collection (
        codeIndex,
        codeIndexBasis
    ) public {
        require(msg.sender == owner_, ErrorCodes.NOT_OWNER);
        require(tvm.pubkey() == 0, ErrorCodes.PUBKEY_MUST_BE_NOT_SET);
        tvm.rawReserve(1 ever, 0);

        TvmBuilder salt;
        salt.store(address(this));
        _codeNft = tvm.setCodeSalt(_codeNft, salt.toCell());

        mintDisabled_ = true;
        currentEpoch_ = 1;
        currentEpochPixelTilePrice_ = 0.1 ever;
        epochTilePriceGrow_ = 0.1 ever;
        currentEpochTilesLeft_ = 10000;
        msg.sender.transfer(0, false, MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS);
    }

    modifier onlyOwner() {
        require(msg.sender == owner_, ErrorCodes.NOT_OWNER);
        _;
    }

    modifier onlyMintEnabled() {
        require(mintDisabled_ == false, ErrorCodes.MINT_DISABLED);
        _;
    }

    function changeOwner(address newOwner) external onlyOwner {
        require(newOwner.value != 0, ErrorCodes.BAD_NEW_OWNER);
        owner_ = newOwner;
        msg.sender.transfer(0, false, MsgFlag.REMAINING_GAS);
    }


    function disableMint() external override responsible onlyOwner returns(bool) {
        mintDisabled_ = true;
        emit MintDisabledChanged(mintDisabled_);
        return { value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false } mintDisabled_;
    }

    function enableMint() external override responsible onlyOwner returns(bool) {
        mintDisabled_ = false;
        emit MintDisabledChanged(mintDisabled_);
        return { value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false } mintDisabled_;
    }

    function getMintDisabled() external override responsible returns (bool){
        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false } mintDisabled_;
    }

    function changeEpoch() external override responsible onlyOwner returns(uint32, uint128) {
        _changeEpoch();
        return {value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false } (currentEpoch_, currentEpochPixelTilePrice_);
    }

    function setNftBurningBlocked(uint32 nftId, bool isBlocked) external onlyOwner  {
        SegmintNft(_resolveNft(nftId)).setBurningBlocked{value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS}(isBlocked, msg.sender);
    }

    function _buildNftState(
        TvmCell code,
        uint256 id
    ) internal virtual override(TIP4_2Collection, TIP4_3Collection) pure returns (TvmCell) {
        return tvm.buildStateInit({
            contr: SegmintNft,
            varInit: {_id: id},
            code: code
        });
    }

    function _validateClaim(uint10 pixelStartX, uint10 pixelStartY, uint10 pixelEndX, uint10 pixelEndY) private inline returns (uint7, uint7, uint7, uint7, uint14) {
        if (pixelStartX % 10 != 0 || pixelStartY % 10 != 0 || pixelEndX % 10 != 0 || pixelEndY % 10 != 0 || pixelStartX >= pixelEndX || pixelStartY >= pixelEndY || pixelEndX > 1000 || pixelEndY > 1000) {
            revert(ErrorCodes.WRONG_TILE_COORDS);
        }

        // 0 - 99
        uint7 tilesStartX = uint7(pixelStartX / 10);
        uint7 tilesStartY = uint7(pixelStartY / 10);

        // 0 - 100
        uint7 tilesWidthCount = uint7((pixelEndX - pixelStartX) / 10);
        uint7 tilesHeightCount = uint7((pixelEndY - pixelStartY) / 10);

        uint14 tilesCount = uint14(tilesWidthCount) * uint14(tilesHeightCount);
        if (tilesCount > 100) {
            revert(ErrorCodes.WRONG_TILE_COORDS);
        }
        return (tilesStartX, tilesStartY, tilesWidthCount, tilesHeightCount, tilesCount);
    }

    function claimTiles(uint10 pixelStartX, uint10 pixelStartY, uint10 pixelEndX, uint10 pixelEndY, TileColors[] tilesToColorify, string description, string url, uint128 coinsToRedrawOneTile) external override onlyMintEnabled {

        // we always store balance + 1 venom from incoming message for storage payments
        (uint7 tilesStartX, uint7 tilesStartY, uint7 tilesWidthCount, uint7 tilesHeightCount, uint14 tilesCount) = _validateClaim(pixelStartX, pixelStartY, pixelEndX, pixelEndY);

        uint32 nftId = nftCounter_;
        nftCounter_ += 1;
        uint64 nftIdWithEpoch = (uint64(nftId) << 32) | currentEpoch_;

        for (uint14 tileX = tilesStartX; tileX < tilesStartX + tilesWidthCount; tileX++) {
            uint14 shiftedX = tileX << 7;
            for (uint7 tileY = tilesStartY; tileY < tilesStartY + tilesHeightCount; tileY++) {
                // set this tile index to be owned by nft
                // we already checked is this index free in _validateClaim
                optional(uint64) oPrevOwner = tileOwner_.getSet(shiftedX | tileY, nftIdWithEpoch);
                if (oPrevOwner.hasValue()) {
                    require(oPrevOwner.get() & 4294967295 < currentEpoch_, ErrorCodes.TILE_ALREADY_TAKEN);
                }
            }
        }

        uint128 currentPrice = tilesCount * currentEpochPixelTilePrice_;
        uint128 prevPrice = currentPrice - tilesCount * epochTilePriceGrow_;

        // we check because messages not bounce on action phase.
        // current price + 0.2 venom for gas + 0.7 venom for NFT deployment + 0.05 venom for storage payment
        // + 0.05 venom for maximum forward fee = 1 ever
        require(msg.value > currentPrice + 1 ever);

        // We reverse on contract 0.1 venom for payment storage + diff between prev epoch price and current epoch price
        // for rebate
        tvm.rawReserve(0.05 ever + prevPrice, 4);
        emit NftMinted(nftId, currentEpoch_, msg.sender, pixelStartX, pixelStartY, pixelEndX, pixelEndY);

        // generate next epoch
        currentEpochTilesLeft_ -= tilesWidthCount * tilesHeightCount;
        // if less then 15% left start new epoch.
        if (currentEpochTilesLeft_ < 1500) {
            _changeEpoch();
        }

        TvmCell stateNft = _buildNftState(_codeNft, uint256(nftId));
        address nftAddr = new SegmintNft{
                stateInit: tvm.buildStateInit({
                    contr: SegmintNft,
                    varInit: {_id: nftId},
                    code: _codeNft
                }),
                value: 0.7 ever + currentPrice - prevPrice,
                flag: MsgFlag.SENDER_PAYS_FEES
        } (
            msg.sender,
            owner_,
            remainOnNft_,
            _indexDeployValue,
            _indexDestroyValue,
            _codeIndex,
            currentPrice,
            pixelStartX,
            pixelStartY,
            pixelEndX,
            pixelEndY,
            description,
            url
        );

        SegmintNft(nftAddr).colorify{value: 0, bounce: false, flag: MsgFlag.ALL_NOT_RESERVED}({tilesToColorify: tilesToColorify, description: description, url: url, coinsToRedrawOneTile: coinsToRedrawOneTile, sendGasBack: msg.sender});
    }

    function colorifyTile(uint32 nftId, TileColors tileColors, uint10 tilePixelX, uint10 tilePixelY, address sendGasBack) external override {
        require(msg.sender == _resolveNft(nftId), ErrorCodes.WRONG_NFT);
         tvm.rawReserve(0, 4);

        uint14 index = (uint14(tilePixelX/10) << 7) | uint14(tilePixelY/10);
        optional(uint64) oNftIdWithEpoch = tileOwner_.fetch(index);

        if (oNftIdWithEpoch.hasValue()) {
            uint64 nftIdWithEpoch = oNftIdWithEpoch.get();
            if (uint32(nftIdWithEpoch >> 32) == nftId) {
                // We iterate via tile color arrays
                // because i'm not really sure how solidity operate with arrays
                // and big structs. Due to TvmCell structure I think solidity doesn't
                // really check how many elements are packed into array.
                // So any bad gay can try to insert really big array to Increase contract storage
                // payments.
                uint80[] emptyColors = new uint80[](10);
                TileColors newColors = TileColors(emptyColors, emptyColors, emptyColors);
                for (uint y = 0; y < 10; y++) {
                    newColors.r[y] = tileColors.r[y];
                    newColors.g[y] = tileColors.g[y];
                    newColors.b[y] = tileColors.b[y];
                }
                tiles_[index] = newColors;
                emit TileColorify(nftId, uint32(nftIdWithEpoch & 4294967295), tilePixelX, tilePixelY, newColors);
                // We don't return the change, to avoid creating too many messages
                // we just use good gas calculation and param  uint128 coinsToRedrawOneTile in nft
                // to manage them.
            } else {
                sendGasBack.transfer( 0,  false, MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS);
            }
        }
    }

    function burnNft(uint32 nftId, uint128 lockedAmount, uint10 nftPixelStartX, uint10 nftPixelStartY, uint10 nftPixelEndX, uint10 nftPixelEndY) external override {
        require(msg.sender == _resolveNft(nftId), ErrorCodes.WRONG_NFT);

        (uint7 tilesStartX, uint7 tilesStartY, uint7 tilesWidthCount, uint7 tilesHeightCount, uint14 tilesCount) = _validateClaim(nftPixelStartX, nftPixelStartY, nftPixelEndX, nftPixelEndY);
        bool shouldCancel = false;

        for (uint14 tileX = tilesStartX; tileX < tilesStartX + tilesWidthCount; tileX++) {
            uint14 shiftedX = tileX << 7;
            for (uint7 tileY = tilesStartY; tileY < tilesStartY + tilesHeightCount; tileY++) {
                uint64 prevOwnerInfo = tileOwner_[shiftedX | tileY];
                uint32 ownedByNftId = uint32(prevOwnerInfo >> 32);
                if (ownedByNftId == nftId) {
                    shouldCancel = true;
                }
            }
        }
        if (shouldCancel) {
            SegmintNft(msg.sender).onBurnError{value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS}();
        } else {
            SegmintNft(msg.sender).onBurnSuccess{value: lockedAmount, bounce: false, flag: MsgFlag.REMAINING_GAS}();
        }
    }

    // To call offchain to get tile info and pixels
    function getTile(uint10 tilePixelX, uint10 tilePixelY) external override responsible returns (uint8[] pixels, uint32 nftId, uint32 epoch) {
        // 2 ** 32
        nftId = uint32(4294967295);
        uint14 index = (uint14(tilePixelX/10) << 7) | uint14(tilePixelY/10);
        optional(TileColors) oTileColors = tiles_.fetch(index);
        if (oTileColors.hasValue()) {
            TileColors tileColors = oTileColors.get();
            uint64 nftOwnerData = tileOwner_[index];
            nftId = uint32(nftOwnerData >> 32);
            epoch = uint32(nftOwnerData & 4294967295);
            pixels = _convertTileToPixels(tileColors);
        } else {
            optional(uint64) oNftOwnerData = tileOwner_.fetch(index);
            if (oNftOwnerData.hasValue()) {
                // nft claimed but not colored
                uint64 nftOwnerData = oNftOwnerData.get();
                nftId = uint32(nftOwnerData >> 32);
                epoch = uint32(nftOwnerData & 4294967295);
            }
            for (uint y = 0; y < 10; y++)  {
                for (uint x = 0; x < 10; x++)  {
                    pixels.push(uint8(0));
                    pixels.push(uint8(0));
                    pixels.push(uint8(0));
                }
            }
        }
        return{value: 0, bounce: false, flag: 64} (pixels, nftId, epoch);
    }

    // To call offchain to convert raw colors to pixels
    function convertTileColorsToPixels(TileColors tileColors) external override responsible returns(uint8[] pixels) {
        return{value: 0, bounce: false, flag: 64} _convertTileToPixels(tileColors);
    }

    function getTilesColors() external responsible returns(mapping (uint14 => TileColors)) {
        return{value: 0, bounce: false, flag: 64} tiles_;
    }

    function getTilesOwners() external responsible returns(mapping (uint14 => uint64)) {
        return{value: 0, bounce: false, flag: 64} tileOwner_;
    }

    function getData() external responsible returns(uint32 nftCounter, uint32 epoch, uint128 currentEpochPixelTilePrice, bool mintDisabled) {
        return{value: 0, bounce: false, flag: 64} (nftCounter_, currentEpoch_, currentEpochPixelTilePrice_, mintDisabled_);
    }

    function getNftIndexCodeHash(
        address _owner
    ) external view responsible returns (string codeHash) {
        TvmBuilder salt;
        salt.store("nft");
        salt.store(address(this));
        salt.store(_owner);
        TvmCell code = tvm.setCodeSalt(_codeIndex, salt.toCell());
        return{value: 0, bounce: false, flag: 64} format("{:064x}", tvm.hash(code));
    }

    function _convertTileToPixels(TileColors tileColors) private inline returns (uint8[] pixels)  {
        for (uint y = 0; y < 10; y++)  {
            for (uint x = 0; x < 10; x++)  {
                pixels.push(uint8( (tileColors.r[y] >> ((9 - x) * 8)) & 0xff ));
                pixels.push(uint8( (tileColors.g[y] >> ((9 - x) * 8)) & 0xff ));
                pixels.push(uint8( (tileColors.b[y] >> ((9 - x) * 8)) & 0xff ));
            }
        }
        return pixels;
    }

    function _changeEpoch() private inline {
        currentEpoch_ += 1;
        currentEpochTilesLeft_ = 10000;
        currentEpochPixelTilePrice_ += epochTilePriceGrow_;
        emit EpochChanged(currentEpoch_, currentEpochPixelTilePrice_);
    }
}
